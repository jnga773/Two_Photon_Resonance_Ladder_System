# -*- coding: utf-8 -*-
"""
Created on Fri May 18 12:47:52 2018

@author: Jacob
"""

import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['text.usetex'] = True
plt.rcParams['font.family'] = 'serif'

plt.close('all')

###############################################################################
#                         Plot with Spectrum                                  #
###############################################################################
def spectrum(tau_input, corr_input, pos=None, norm="integral"):
    """
    Calculate the power spectrum corresponding to a two-time correlation
    function using FFT.

    Input
    ------------
    tau_input : array_likee
        list of times generated by code.
    corr_input : like
        list of imaginary first-order correlation values.
    pos : conditional
        Used for contour plots to define positive or negative frequencies.
        None - Both positive and negative frequencies.
        False - Negative frequencies.
        True - Positive frequencies.
    norm : string
        Type of normalisation used.
        "integral" - Normalise such that the area under the spectrum is one.
        "peak" - Normalise such that the maximum peak is one.

    Output
    ------------
    spec_output : array_like
        Intensity spectrum of first-order correlation.
    wlise_output : array_like
        List of frequencies
    """
    # Shift the arrays so they are arranged from negative to positive freq
    fft = np.fft.fft(corr_input)#, norm='ortho')
    fft = np.fft.fftshift(fft)
    freq = np.fft.fftfreq(tau_input.shape[0], tau_input[1]-tau_input[0])
    freq = np.fft.fftshift(freq)
    # As the central peak is a delta function, we ignore the plot for w=0. To
    # do this we find the index in wlist where it is equal to 0.0, ignore it,
    # and create a new list excluding this value.
    if pos is True:
        indices = np.where(freq > 0.0)[0]
    elif pos is False:
        indices = np.where(freq < 0.0)[0]
    elif pos is None:
        indices = np.where(freq != 0.0)[0]
    # Remove zero frequency term
    spec_output = fft[indices]
    # Divide by 2 \pi
    spec_output = (np.abs(spec_output) ** 2) / (2 * np.pi)
    # The spectrum is given by the absolute value of the FFT squared.
#    spec = np.abs(spec) ** 2
    wlist_output = freq[indices] # wlist is in terms of FFT frequencies
    wlist_output = np.array(wlist_output) * 2 * np.pi
    if norm == "integral":
        if np.max(spec_output) == 0.0:
            spec_output = spec_output
        else:
            normalise = np.sum(spec_output) * (wlist_output[1] - wlist_output[0])
            spec_output = spec_output / normalise
    elif norm == "peak":
        if np.max(spec_output) == 0.0:
            spec_output = np.zeros(len(wlist_output))
        else:
            spec_output = spec_output / np.max(spec_output)
    return spec_output, wlist_output

def lorenztian(w_in, w0_in, kappa_in):
    """
    docstring
    """
    L_out = ((0.5 * kappa_in) ** 2) / ((w_in - w0_in) ** 2 +\
            ((0.5 * kappa_in) ** 2))
#    normalise_f = np.sum(L_out) * (w_in[1] - w_in[0])
#    L_out = L_out / normalise_f
    L_out = L_out * 0.06
    return L_out

# filename
direc = "./data_files/trajectory/"
name = "tau"
ext = ".txt"
filename = direc + name + ext

# Reading the values of each parameter from the txt file
Omega = float(open(filename).readlines()[0])
delta = float(open(filename).readlines()[1])
xi    = float(open(filename).readlines()[2])
alpha = float(open(filename).readlines()[3])
D_a   = float(open(filename).readlines()[4])
kappa_a = float(open(filename).readlines()[5])
D_b   = float(open(filename).readlines()[6])
kappa_b = float(open(filename).readlines()[7])

# time values
tau = np.loadtxt(fname=filename, dtype='float', usecols=(0,), skiprows=9)
dt = tau[1] - tau[0]

# filename
direc = "./data_files/trajectory/"
name = "correlation"
ext = ".txt"
filename = direc + name + ext
# Extract correlation and cross correlation value
corr = np.genfromtxt(fname=filename, dtype='float', usecols=(0,))
cross_corr = np.genfromtxt(fname=filename, dtype='float', usecols=(1,))
print("initial correlation value", corr[0])
print("initial cross correlation value", cross_corr[0])

# spectrum things
directory = "./data_files/spectrum/"
file = "omega5"
ext = ".txt"

filename = directory + file + ext

# Reading the values of each parameter from the txt file
# List of times from the txt file
tau_spec = np.loadtxt(fname=filename, dtype='float', usecols=(0,), skiprows=5)

# List of correlations from txt file. Sum of the real and imaginary parts
corr_spec = np.loadtxt(fname=filename, dtype='float', usecols=(1,), skiprows=5) + \
            1j * np.loadtxt(fname=filename, dtype='float', usecols=(2,), skiprows=5)

spec, wlist = spectrum(tau_spec, corr_spec)

# spectrum
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=[4, 4])
ax.plot(wlist, spec, color='k')
ax.plot(wlist, lorenztian(wlist, D_a, kappa_a), color='blue', alpha=0.5, ls='dashed')
ax.plot(wlist, lorenztian(wlist, D_b, kappa_b), color='red', alpha=0.5, ls='dashed')

x_ticks_maj = np.linspace(-120, 120, 7)
ax.set_xticks(x_ticks_maj)
ax.set_xlim(-np.abs(alpha), np.abs(alpha))
ax.set_xlabel(r'$\left( \omega - \omega_{d} \right) / \gamma$', fontsize=11)
ax.set_ylabel('Power Spectrum', fontsize=11)
fig.tight_layout()
#fig.savefig("../Images/omega5_Df-60_kappa10_spectrum.pdf")

fig, ax = plt.subplots(nrows=2, ncols=1, sharex=True, figsize=[8,5])

ax[0].plot(tau[:-1], corr, color='k')
ax[0].axhline(y=1.0, color='k', alpha=0.5, ls='dashed')
ax[0].set_ylabel(r'$g^{(2)}(\tau)$')
#ax[0].set_title(r'Master Equation Correlation of Cavity a, $\kappa_a=%s$, $\Delta_{a}=%s$'%(kappa_a, D_a))

ax[1].plot(tau[:-1], cross_corr, color='k')
ax[1].axhline(y=1.0, color='k', alpha=0.5, ls='dashed')
ax[1].set_ylabel(r'$g^{(2)}(\tau)$')
ax[1].set_xlabel(r'$\gamma\tau$')
#ax[1].set_title(r'Master Equation Cross Correlation of Cavity b, $\kappa_{b}=%s$, $\Delta_{b}=%s$'%(kappa_b, D_b))

fig.tight_layout()
