# -*- coding: utf-8 -*-
"""
Created on Thu Apr  5 16:08:23 2018

@author: Jacob
"""

import numpy as np
import matplotlib
import matplotlib.pyplot as plt

import matplotlib.colors as colors
from matplotlib.mlab import bivariate_normal

plt.rcParams['text.usetex'] = True
plt.rcParams['font.family'] = 'serif'

plt.close('all')

###############################################################################
#                       Functions                                             #
###############################################################################
def spectrum(tau_input, corr_input, pos=None, norm="integral"):
    """
    Calculate the power spectrum corresponding to a two-time correlation
    function using FFT.

    Input
    ------------
    tau_input : array_likee
        list of times generated by code.
    corr_input : like
        list of imaginary first-order correlation values.
    pos : conditional
        Used for contour plots to define positive or negative frequencies.
        None - Both positive and negative frequencies.
        False - Negative frequencies.
        True - Positive frequencies.
    norm : string
        Type of normalisation used.
        "integral" - Normalise such that the area under the spectrum is one.
        "peak" - Normalise such that the maximum peak is one.

    Output
    ------------
    spec_output : array_like
        Intensity spectrum of first-order correlation.
    wlise_output : array_like
        List of frequencies
    """
    # Shift the arrays so they are arranged from negative to positive freq
    fft = np.fft.fft(corr_input)#, norm='ortho')
    fft = np.fft.fftshift(fft)
    freq = np.fft.fftfreq(tau_input.shape[0], tau_input[1]-tau_input[0])
    freq = np.fft.fftshift(freq)
    # As the central peak is a delta function, we ignore the plot for w=0. To
    # do this we find the index in wlist where it is equal to 0.0, ignore it,
    # and create a new list excluding this value.
    if pos is True:
        indices = np.where(freq > 0.0)[0]
    elif pos is False:
        indices = np.where(freq < 0.0)[0]
    elif pos is None:
        indices = np.where(freq != 0.0)[0]
    # Remove zero frequency term
    spec_output = fft[indices]
    # Divide by 2 \pi
    spec_output = (np.abs(spec_output) ** 2) / (2 * np.pi)
    # The spectrum is given by the absolute value of the FFT squared.
#    spec = np.abs(spec) ** 2
    wlist_output = freq[indices] # wlist is in terms of FFT frequencies
    wlist_output = np.array(wlist_output) * 2 * np.pi
    if norm == "integral":
        if np.max(spec_output) == 0.0:
            spec_output = spec_output
        else:
            normalise = np.sum(spec_output) * (wlist_output[1] - wlist_output[0])
            spec_output = spec_output / normalise
    elif norm == "peak":
        if np.max(spec_output) == 0.0:
            spec_output = np.zeros(len(wlist_output))
        else:
            spec_output = spec_output / np.max(spec_output)
    return spec_output, wlist_output

def squeezed(matrix_slice_input):
    """
    Takes a row of a matrix and turns it into a one-dimensional array

    Input
    -------
    matrix_slice : matrix_like
        Defined as a 1xN matrix

    Output
    -------
    squeezed_output : array_like
        A one-dimensional array
    """
    squeezed_output = np.squeeze(np.asarray(matrix_slice_input))
    return squeezed_output

def data(directory_f="./data_files/map_delta/"):
    """
    Sort through the data folder for each file "dataXXXX.txt" where XXXX is
    a number 0000 to n. The first column of the txt file is the real part of
    the correlation and the second column is the imaginary part.
    Putting these together into one complex number we create a list corr
    for each file (value of delta). This list is then appened to another list
    m which is then turned into a matrix

    Input
    ---------
    directory : string
        Parent directory where the data files are stored.
        Usually "./data_files/map_delta/data"

    Output
    ---------
    matrix_output : matrix_like
       matrix of correlation data
    """
    from os import listdir

    no_of_files = len(listdir(directory_f)) - 2
    no_of_files = int(no_of_files) # number of files
    matrix_output = []
    for file_f in range(no_of_files):
        f1 = directory + "data"
        f2 = str(file_f).zfill(4)
        f3 = ".txt"
        filename = f1 + f2 + f3
        corr_r = np.genfromtxt(fname=filename, dtype='complex', usecols=(0,))
        corr_i = np.genfromtxt(fname=filename, dtype='complex', usecols=(1,))
        corr_f = corr_r + 1j*corr_i
        matrix_output.append(list(corr_f))
    return np.matrix(matrix_output)

def specmat(tau_input, corr_mat_input, pos=None, norm="integral"):
    """
    tau is a list of tau times, corr_mat is a matrix where each row is a
    correlation function for a value delta, with different delta in the
    rows, and drive is an array of drive frequencies

    Input
    ---------
    tau_input : array_like
       List of times
    corr_mat_input : matrix_like
       Matrix of correlation data generated from data()
    pos : conditional
       Used for contour plots to define positive or negative frequencies.
       None - Both positive and negative frequencies.
       False - Negative frequencies.
       True - Positive frequencies.
    norm : string
        Type of normalisation used.
        "integral" - Normalise such that the area under the spectrum is one.
        "peak" - Normalise such that the maximum peak is one.

    Output
    ---------
    spec_mat_output : matrix_like
        Matrix of power spectrum
    wlist_mat_output : matrix_like
        Matrix of frequency values
    """
    no_of_files = len(corr_mat)
    spec_mat_output = []
    wlist_mat_output = []
    for file_f in range(no_of_files):
        # Take one "slice" of the matrix as an array
        corr_f = squeezed(corr_mat_input[file_f, :])
        # and calculate the spectrum of this array
        spec_f, wlist_f = spectrum(tau_input, corr_f, pos, norm)
        # update wlist to be in terms of frequency, not FFT frequency
 #        wlist = np.array(wlist)
        # Append to matrices
        spec_mat_output.append(list(spec_f))
        wlist_mat_output.append(list(wlist_f))
    spec_mat_output = np.matrix(spec_mat_output).T
    spec_mat_output = np.array(spec_mat_output)
    wlist_mat_output = np.matrix(wlist_mat_output).T
    wlist_mat_output = np.array(wlist_mat_output)
    return spec_mat_output, wlist_mat_output

def shiftedColorMap(cmap, start=0, midpoint=0.5, stop=1.0, name='shiftedcmap'):
    '''
    Function to offset the "center" of a colormap. Useful for
    data with a negative min and positive max and you want the
    middle of the colormap's dynamic range to be at zero.

    Input
    -----
      cmap : The matplotlib colormap to be altered
      start : Offset from lowest point in the colormap's range.
          Defaults to 0.0 (no lower offset). Should be between
          0.0 and `midpoint`.
      midpoint : The new center of the colormap. Defaults to 
          0.5 (no shift). Should be between 0.0 and 1.0. In
          general, this should be  1 - vmax / (vmax + abs(vmin))
          For example if your data range from -15.0 to +5.0 and
          you want the center of the colormap at 0.0, `midpoint`
          should be set to  1 - 5/(5 + 15)) or 0.75
      stop : Offset from highest point in the colormap's range.
          Defaults to 1.0 (no upper offset). Should be between
          `midpoint` and 1.0.
    '''
    cdict = {
        'red': [],
        'green': [],
        'blue': [],
        'alpha': []
    }

    # regular index to compute the colors
    reg_index = np.linspace(start, stop, 257)

    # shifted index to match the data
    shift_index = np.hstack([
        np.linspace(0.0, midpoint, 128, endpoint=False), 
        np.linspace(midpoint, 1.0, 129, endpoint=True)
    ])

    for ri, si in zip(reg_index, shift_index):
        r, g, b, a = cmap(ri)

        cdict['red'].append((si, r, r))
        cdict['green'].append((si, g, g))
        cdict['blue'].append((si, b, b))
        cdict['alpha'].append((si, a, a))

    newcmap = colors.LinearSegmentedColormap(name, cdict)
    plt.register_cmap(cmap=newcmap)

    return newcmap

###############################################################################
#                       Data values                                           #
###############################################################################
directory = "./data_files/map_delta/"
ext = ".txt"
file = "spectrum"

time_name = "time"
param_name = "param"


tau = np.genfromtxt(fname=directory + time_name + ext, dtype='float',
                    usecols=(0,))
omega = float(open(directory + param_name + ext).readlines()[0])
xi = float(open(directory + param_name + ext).readlines()[1])
alpha = float(open(directory + param_name + ext).readlines()[2])
delta = np.genfromtxt(fname=directory + param_name + ext, dtype='float',
                      skip_header=4)

corr_mat = data()
###############################################################################
#                       Single Graph Plotting                                 #
###############################################################################
#delt = delta[-1] # for a given delta
#n = np.where(delta == delt)[0][0] # the index where delt is in delta list
#corr = squeezed(corr_mat[n, :]) # Taking a slice of the data
#spec, wlist = spectrum(tau, corr)
#
## Plot the correlation function
#plt.figure()
#plt.plot(tau, np.abs(corr), color='k')
#
#plt.xlim(np.min(tau), np.max(tau))
#plt.ylim(np.min((corr.real)), np.max(corr.real))
#
#plt.xlabel(r'$\tau$')
#plt.ylabel(r'$\lim_{t\to\infty} \langle \hat{\sigma}_{+}(t+\tau) \hat{' +
#           r'\sigma}_{-}(t) \rangle$')
#plt.title('Steady State Correlation Function')
#
#plt.tight_layout()
#plt.show()
#
##Plot the spectrum
#plt.figure()
#plt.plot(wlist, spec, color='k')
#
#plt.xlim(-np.abs(alpha), np.abs(alpha))
##plt.xlim(min(peaks)-20, max(peaks)+20)
#
#plt.xlabel(r'$ \left( \omega - \omega_{d} \right) / \gamma $')
#plt.ylabel('Power Spectrum')
#plt.title(r'$\left(\Omega, \delta, \xi, \alpha\right)=\left(' +
#          r'%s, %s, %s, %s\right)$'%(omega, round(delt, 1), xi, round(alpha, 1)))
#
#plt.tight_layout()
#plt.show()
## plt.savefig("./Images/weak_drive_Omega=%s,xi=%s.pdf"%(omega,xi))

###############################################################################
#                       Spectrum Map Plotting                                 #
###############################################################################
Z_pos, Y_pos = specmat(tau, corr_mat, pos=True)
Z_neg, Y_neg = specmat(tau, corr_mat, pos=False)
X = np.zeros(shape=Y_neg.shape)
for i in range(Y_neg.shape[0]):
    X[i, :] = delta

plt.figure(figsize=[6.5, 2.65])

oldmap = plt.cm.inferno_r
shift = shiftedColorMap(oldmap, start=0, midpoint=0.05, stop=1.0,
                        name='shifted_cmap')

plt.pcolormesh(X, Y_pos, Z_pos, vmin=0, vmax=np.max(Z_pos),
               cmap='shifted_cmap')
plt.pcolormesh(X, Y_neg, Z_neg, vmin=0, vmax=np.max(Z_neg),
               cmap='shifted_cmap')

plt.xlabel(r'$\delta / \gamma$', fontsize=11)
plt.ylabel(r'$ \left( \omega - \omega_{d} \right) / \gamma $', fontsize=11)

cbar = plt.colorbar()
#cbar.set_label('Power Spectrum (a.u)')
cbar.set_label('Power Spectrum')

# Plot limits
plt.xlim(np.min(delta), np.max(delta))
plt.ylim(-np.abs(alpha), np.abs(alpha))

plt.tight_layout()
#plt.savefig("../Images/delta_-20_80_omega0001.eps")
plt.savefig("../Images/delta_map_high_drive_xi_1_5.eps")
